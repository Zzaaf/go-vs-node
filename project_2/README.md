# Project 2: Многопоточность — это просто! Параллельный парсер

## Описание
Демонстрация того, как легко в Go писать многопоточные приложения с помощью горутин, каналов и WaitGroup.

## Что изучаем
- **Горутины** (`go func()`) - легковесные потоки
- **Каналы** (`chan`) - безопасная передача данных между горутинами
- **WaitGroup** - ожидание завершения всех горутин
- **Сравнение** последовательного и параллельного выполнения

## Запуск
```bash
go run main.go
```

## Что происходит

### 1. Последовательный парсинг (медленный)
- Парсим URL один за другим
- Каждый запрос ждет завершения предыдущего
- Общее время = сумма всех запросов

### 2. Параллельный парсинг (быстрый)
- Запускаем горутину для каждого URL
- Все запросы выполняются одновременно
- Общее время ≈ времени самого медленного запроса

## Ключевые концепции

### Горутины
```go
go func() {
    // Код выполняется в отдельной горутине
}()
```

### WaitGroup
```go
var wg sync.WaitGroup
wg.Add(1)        // Увеличиваем счетчик
go func() {
    defer wg.Done() // Уменьшаем при завершении
    // Работа
}()
wg.Wait()        // Ждем завершения всех
```

### Каналы
```go
results := make(chan Result, 10) // Буферизованный канал
results <- result                // Отправка
result := <-results              // Получение
close(results)                   // Закрытие
```

## Ожидаемые результаты
- Параллельный парсинг будет в 3-5 раз быстрее
- Все URL парсятся одновременно
- Код остается читаемым и понятным

## Преимущества Go
1. **Простота**: Многопоточность без сложности
2. **Производительность**: Горутины очень дешевые
3. **Безопасность**: Каналы предотвращают race conditions
4. **Читаемость**: Код остается понятным
